<?xml version="1.0" encoding="UTF-8"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>李晓晨</title>
    <description>欢迎来到我的个人站~</description>
    <link>http://localhost:4000/</link>
    <atom:link href="http://localhost:4000/feed.xml" rel="self" type="application/rss+xml"/>
    <pubDate>Sat, 23 Sep 2017 16:25:59 +0800</pubDate>
    <lastBuildDate>Sat, 23 Sep 2017 16:25:59 +0800</lastBuildDate>
    <generator>Jekyll v3.5.2</generator>
    
      <item>
        <title>CocoaPods使用心得</title>
        <description>&lt;h3 id=&quot;简介&quot;&gt;简介：&lt;/h3&gt;
&lt;p&gt;　本章介绍什么是 &lt;code class=&quot;highlighter-rouge&quot;&gt;CocoaPods&lt;/code&gt; ,如何使用 &lt;code class=&quot;highlighter-rouge&quot;&gt;CocoaPods&lt;/code&gt; , 以及 &lt;code class=&quot;highlighter-rouge&quot;&gt;CocoaPods&lt;/code&gt; 的原理,和使用 &lt;code class=&quot;highlighter-rouge&quot;&gt;CocoaPods&lt;/code&gt; 时经常出现的一些问题。&lt;/p&gt;

&lt;p&gt;　Cocoapods 是 OS X 和 iOS 下的一个第三方库管理工具。我们能使用CocoaPods添加被称作 “Pods”的依赖库,并轻松管理它们的版本,CocoaPods会帮我们配置好这些三方库的路径及开发环境,极大的提升了开发者的工作效率。&lt;/p&gt;

&lt;h3 id=&quot;安装cocoapods&quot;&gt;安装CocoaPods　&lt;/h3&gt;

&lt;p&gt;　Mac下自带ruby,使用ruby的gem命令安装,ruby的软件源被墙了,把官方的ruby源替换成国内的淘宝源。&lt;/p&gt;

&lt;h3 id=&quot;更换gem源&quot;&gt;更换Gem源&lt;/h3&gt;

&lt;div class=&quot;language-bash highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;gp&quot;&gt;$ &lt;/span&gt;gem sources --remove https://rubygems.org/
&lt;span class=&quot;gp&quot;&gt;$ &lt;/span&gt;gem sources -a https://ruby.taobao.org/
&lt;span class=&quot;gp&quot;&gt;$ &lt;/span&gt;gem sources -l
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;ul&gt;
  &lt;li&gt;1.移除掉原有的源（服务器在国外，速度较慢）。&lt;/li&gt;
  &lt;li&gt;2.等1有反应之后再敲2命令（替换成淘宝上的ruby镜像https）。&lt;/li&gt;
  &lt;li&gt;3.验证是否成功。成功如下：&lt;/li&gt;
&lt;/ul&gt;

&lt;div class=&quot;language-bash highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;
&lt;span class=&quot;k&quot;&gt;***&lt;/span&gt; CURRENT SOURCES &lt;span class=&quot;k&quot;&gt;***&lt;/span&gt;

http://ruby.taobao.org/

&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h3 id=&quot;更新gem源&quot;&gt;更新Gem源&lt;/h3&gt;

&lt;div class=&quot;language-bash highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;
sudo gem update --system

&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h3 id=&quot;安装cocoapods-1&quot;&gt;安装cocoapods&lt;/h3&gt;

&lt;div class=&quot;language-bash highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;
&lt;span class=&quot;gp&quot;&gt;$ &lt;/span&gt;sudo gem install cocoapods
&lt;span class=&quot;gp&quot;&gt;$ &lt;/span&gt;pod setup

&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;pod setup 在执行时会比较慢，因为Cocoapods 要将它的信息下载到 ~/.cocoapods目录下, 耐心等待…&lt;/p&gt;

&lt;h4 id=&quot;提升cocoapods的安装速度&quot;&gt;提升cocoapods的安装速度&lt;/h4&gt;

&lt;p&gt;所有的项目的 Podspec 文件都托管在https://github.com/CocoaPods/Specs。第一次执行 pod setup 时，CocoaPods 会将这些podspec索引文件更新到本地的 ~/.cocoapods/目录下，这个索引文件比较大，有 80M 左右。
作者akinliu 在 gitcafe 和 oschina 上建立了 CocoaPods 索引库的镜像(在国内),我们可以使用CocoaPods国内的镜像索引，操作时会快多了,如gitcafe：&lt;/p&gt;

&lt;div class=&quot;language-bash highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;
pod repo remove master
pod repo add master https://gitcafe.com/akuandev/Specs.git
pod repo update

&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h3 id=&quot;使用cocoapods&quot;&gt;使用cocoapods&lt;/h3&gt;

&lt;p&gt;cocoapods安装完成后，使用 pod search 命令来验证一下&lt;/p&gt;

&lt;div class=&quot;language-bash highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;
pod search AFNetworking


&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;终端将会有如下结果：&lt;/p&gt;

&lt;div class=&quot;language-bash highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;
&lt;span class=&quot;gp&quot;&gt;-&amp;gt; &lt;/span&gt;AFNetworking &lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;3.0.4&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt;
A delightful iOS and OS X networking framework.
pod &lt;span class=&quot;s1&quot;&gt;'AFNetworking'&lt;/span&gt;, &lt;span class=&quot;s1&quot;&gt;'~&amp;gt; 3.0.4'&lt;/span&gt;
- Homepage: https://github.com/AFNetworking/AFNetworking
- Source:   https://github.com/AFNetworking/AFNetworking.git
- Versions: 3.0.4, 3.0.3, 3.0.2, 3.0.1, 3.0.0, 3.0.0-beta.3, 3.0.0-beta.2,
3.0.0-beta.1, 2.6.3, 2.6.2, 2.6.1, 2.6.0, 2.5.4, 2.5.3, 2.5.2, 2.5.1, 2.5.0,
2.4.1, 2.4.0, 2.3.1, 2.3.0, 2.2.4, 2.2.3, 2.2.2, 2.2.1, 2.2.0, 2.1.0, 2.0.3,
2.0.2, 2.0.1, 2.0.0, 2.0.0-RC3, 2.0.0-RC2, 2.0.0-RC1, 1.3.4, 1.3.3, 1.3.2,
1.3.1, 1.3.0, 1.2.1, 1.2.0, 1.1.0, 1.0.1, 1.0, 1.0RC3, 1.0RC2, 1.0RC1,
0.10.1, 0.10.0, 0.9.2, 0.9.1, 0.9.0, 0.7.0, 0.5.1 &lt;span class=&quot;o&quot;&gt;[&lt;/span&gt;master repo]
- Subspecs:
- AFNetworking/Serialization &lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;3.0.4&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt;
- AFNetworking/Security &lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;3.0.4&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt;
- AFNetworking/Reachability &lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;3.0.4&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt;
- AFNetworking/NSURLSession &lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;3.0.4&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt;
- AFNetworking/UIKit &lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;3.0.4&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt;


&lt;span class=&quot;gp&quot;&gt;-&amp;gt; &lt;/span&gt;AFNetworking+AutoRetry &lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;0.0.5&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt;
Auto Retries &lt;span class=&quot;k&quot;&gt;for &lt;/span&gt;AFNetworking requests
pod &lt;span class=&quot;s1&quot;&gt;'AFNetworking+AutoRetry'&lt;/span&gt;, &lt;span class=&quot;s1&quot;&gt;'~&amp;gt; 0.0.5'&lt;/span&gt;
- Homepage: https://github.com/shaioz/AFNetworking-AutoRetry
- Source:   https://github.com/shaioz/AFNetworking-AutoRetry.git
- Versions: 0.0.5, 0.0.4, 0.0.3, 0.0.2, 0.0.1 &lt;span class=&quot;o&quot;&gt;[&lt;/span&gt;master repo]

.........太多了，省略

&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;pod search 是CocoaPods的一个搜索命令,我们可以用来搜索任何托管在CocoaPods上的三方库。&lt;/p&gt;

&lt;p&gt;使用CocoaPods时需要新建一个 Podfile 的文件,cd 到 我的Demo项目里，Demo目录下有三个文件&lt;/p&gt;

&lt;div class=&quot;language-bash highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;
Demo 、  Demo.xcodeproj  、 DemoTests

&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;新建 Podfile&lt;/p&gt;

&lt;div class=&quot;language-bash highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;
touch Podfile

&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;vim 编辑 Podfile&lt;/p&gt;

&lt;div class=&quot;language-bash highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;vim Podfile
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;p&gt;由于是新建的 Podfile 里面应该是空白的。然后我们在里面添加依赖库，格式如下：&lt;/p&gt;

&lt;div class=&quot;language-bash highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;
platform :ios
pod &lt;span class=&quot;s1&quot;&gt;'Reachability'&lt;/span&gt;,  &lt;span class=&quot;s1&quot;&gt;'~&amp;gt; 3.0.0'&lt;/span&gt;
pod &lt;span class=&quot;s1&quot;&gt;'ASIHTTPRequest'&lt;/span&gt;

&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;‘~&amp;gt; 3.0.0’ 是 Reachability 的版本号, 设定了版本号CocoaPods就会下载对应的版本,ASIHTTPRequest没指定版本号,CocoaPods就会下载最新版本的ASIHTTPRequest。
退出编辑，执行 pod install 下载三方库。&lt;/p&gt;

&lt;div class=&quot;language-bash highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;
pod install

&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;p&gt;完成后我Demo项目下的文件多了几个:&lt;/p&gt;

&lt;div class=&quot;language-bash highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;Demo 、  Demo.xcodeproj  、 DemoTests （之前的三个）

Demo.xcworkspace 、Podfile 、Podfile.lock 、Pods
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;这个时候我们打开Demo项目是点击 Demo.xcworkspace 文件了，到此CocoaPods的基本使用已经讲完了，接下来的CocoaPods的原理，和让我们自己的三方库也支持CocoaPods。&lt;/p&gt;

&lt;p&gt;待续…&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;http://blog.jobbole.com/53365/&quot;&gt;深入理解 CocoaPods&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;p&gt;转载请注明：&lt;a href=&quot;http://baixin&quot;&gt;潘柏信的博客&lt;/a&gt; » &lt;a href=&quot;http://baixin.io/2016/04/CocoaPod_Use/&quot;&gt;点击阅读原文&lt;/a&gt;&lt;/p&gt;

</description>
        <pubDate>Sat, 02 Apr 2016 00:00:00 +0800</pubDate>
        <link>http://localhost:4000/2016/04/CocoaPod_Use/</link>
        <guid isPermaLink="true">http://localhost:4000/2016/04/CocoaPod_Use/</guid>
        
        <category>iOS</category>
        
        
      </item>
    
      <item>
        <title>iOS动态更新</title>
        <description>&lt;ul&gt;
  &lt;li&gt;1、控件到 &lt;code class=&quot;highlighter-rouge&quot;&gt;window&lt;/code&gt; 的层级关系:&lt;/li&gt;
  &lt;li&gt;2、分析控件的详细路径:&lt;/li&gt;
  &lt;li&gt;3、动态修改控件:&lt;/li&gt;
  &lt;li&gt;4、工具篇:&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;视图的层级关系&quot;&gt;视图的层级关系&lt;/h3&gt;

&lt;p&gt;每个 &lt;code class=&quot;highlighter-rouge&quot;&gt;App&lt;/code&gt; , 至少有一个根 &lt;code class=&quot;highlighter-rouge&quot;&gt;Window&lt;/code&gt; , 通常情况下我们只用一个 。&lt;code class=&quot;highlighter-rouge&quot;&gt;window&lt;/code&gt; 有一个 &lt;code class=&quot;highlighter-rouge&quot;&gt;rootViewController&lt;/code&gt; , 这就是我们所谓的根视图 , 我们所有的控制器都是放在 &lt;code class=&quot;highlighter-rouge&quot;&gt;rootViewController&lt;/code&gt; 里面的。&lt;/p&gt;

&lt;p&gt;如果在项目里有了这么一个路径 , 我们可以做什么呢？&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;在当项目很复杂 , 可以其它地方可以直接修改这个控件的状态&lt;/li&gt;
  &lt;li&gt;当某个控件命名存在却又没有显示出来 , 可以通过路径来辅助查找&lt;/li&gt;
  &lt;li&gt;由服务器下发一些配置 , 使用 &lt;code class=&quot;highlighter-rouge&quot;&gt;Runtime&lt;/code&gt; 去动态的修改已上线的项目&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;下面将介绍如何使用代码来找出这些视图(控件)的路径&lt;/p&gt;

&lt;h3 id=&quot;分析控件的详细路径&quot;&gt;分析控件的详细路径&lt;/h3&gt;

&lt;h4 id=&quot;1找出根-window-&quot;&gt;1、找出根 &lt;code class=&quot;highlighter-rouge&quot;&gt;Window&lt;/code&gt; :&lt;/h4&gt;

&lt;p&gt;每一个视图、控件 , 他们最终的根都是main函数返回的 &lt;code class=&quot;highlighter-rouge&quot;&gt;application&lt;/code&gt; , 通过 &lt;code class=&quot;highlighter-rouge&quot;&gt;[UIApplication sharedApplication]&lt;/code&gt; 可以得到 。 &lt;code class=&quot;highlighter-rouge&quot;&gt;application&lt;/code&gt; 的 &lt;code class=&quot;highlighter-rouge&quot;&gt;windows&lt;/code&gt; 属性是一个数组 , 这里面装的是这个应用的所有 &lt;code class=&quot;highlighter-rouge&quot;&gt;Window&lt;/code&gt; , 我们通常用的是第一个也就是 &lt;code class=&quot;highlighter-rouge&quot;&gt;application.windows[0]&lt;/code&gt;&lt;/p&gt;

&lt;h4 id=&quot;2遍历视图-&quot;&gt;2、遍历视图 :&lt;/h4&gt;

&lt;p&gt;得到了 &lt;code class=&quot;highlighter-rouge&quot;&gt;window&lt;/code&gt; 对象一切都好办了 。 然后拿到 &lt;code class=&quot;highlighter-rouge&quot;&gt;window&lt;/code&gt; 的 &lt;code class=&quot;highlighter-rouge&quot;&gt;rootViewController&lt;/code&gt; , 在获取 &lt;code class=&quot;highlighter-rouge&quot;&gt;rootViewController&lt;/code&gt; 里面所有的 &lt;code class=&quot;highlighter-rouge&quot;&gt;childViewControllers&lt;/code&gt; 和 &lt;code class=&quot;highlighter-rouge&quot;&gt;view&lt;/code&gt; 里的 &lt;code class=&quot;highlighter-rouge&quot;&gt;subviews&lt;/code&gt; , 一直递归下去就可以得到当前屏幕里所有视图对象了 , 同时可以通过 &lt;code class=&quot;highlighter-rouge&quot;&gt;runtime&lt;/code&gt; 把它们的 &lt;code class=&quot;highlighter-rouge&quot;&gt;property&lt;/code&gt;、&lt;code class=&quot;highlighter-rouge&quot;&gt;delegate&lt;/code&gt; 都获取出来。&lt;/p&gt;

&lt;p&gt;结合 &lt;code class=&quot;highlighter-rouge&quot;&gt;Reveal&lt;/code&gt; 或者 &lt;code class=&quot;highlighter-rouge&quot;&gt;Xcode&lt;/code&gt; 自带的 &lt;code class=&quot;highlighter-rouge&quot;&gt;Captuer View Hiearachy&lt;/code&gt; , 我们可以推测一下这两个的的实现原理了 :&lt;/p&gt;

&lt;p&gt;1、根据应用得到根视图  &lt;br /&gt;
2、递归获取里面的所有控件 &lt;br /&gt;
3、按照他们的层级关系一层一层的画出来&lt;/p&gt;

&lt;h3 id=&quot;动态修改控件&quot;&gt;动态修改控件&lt;/h3&gt;

&lt;p&gt;1、把上面获取到的所有控件的详细信息上传到服务器 。 &lt;br /&gt;
2、根据业务需求由服务器给我们下发对应的配置列表，以 &lt;code class=&quot;highlighter-rouge&quot;&gt;button&lt;/code&gt; 为例 : 配置列表里必须要有 :&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;1)、&lt;code class=&quot;highlighter-rouge&quot;&gt;button&lt;/code&gt; 的全路径 : 如 &lt;code class=&quot;highlighter-rouge&quot;&gt;UIWindow&lt;/code&gt; -&amp;gt; &lt;code class=&quot;highlighter-rouge&quot;&gt;UIWindow&lt;/code&gt; -&amp;gt; &lt;code class=&quot;highlighter-rouge&quot;&gt;UIView&lt;/code&gt; -&amp;gt; &lt;code class=&quot;highlighter-rouge&quot;&gt;UIView&lt;/code&gt; -&amp;gt; &lt;code class=&quot;highlighter-rouge&quot;&gt;UILayoutContainerView&lt;/code&gt; -&amp;gt; &lt;code class=&quot;highlighter-rouge&quot;&gt;UITabBar&lt;/code&gt; -&amp;gt; &lt;code class=&quot;highlighter-rouge&quot;&gt;UIView&lt;/code&gt; —&amp;gt; &lt;code class=&quot;highlighter-rouge&quot;&gt;UIButton&lt;/code&gt;&lt;/p&gt;
&lt;/blockquote&gt;

&lt;blockquote&gt;
  &lt;p&gt;2)、&lt;code class=&quot;highlighter-rouge&quot;&gt;button&lt;/code&gt; 的唯一标识 : 如 &lt;code class=&quot;highlighter-rouge&quot;&gt;tag&lt;/code&gt; 值或自己实现的一套算法生成的唯一标识 , 目的是防止与 &lt;code class=&quot;highlighter-rouge&quot;&gt;button&lt;/code&gt; 同一层次的视图搞混 。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;blockquote&gt;
  &lt;p&gt;3)、 根据路径及唯一标识来匹配 &lt;code class=&quot;highlighter-rouge&quot;&gt;App&lt;/code&gt; 里的控件 , 匹配和上面的查找原理是相通的。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;blockquote&gt;
  &lt;p&gt;4)、 匹配成功代表  &lt;code class=&quot;highlighter-rouge&quot;&gt;button&lt;/code&gt; 确实存在 , 根据业务需求做后续操作 。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;blockquote&gt;
  &lt;p&gt;提示: 匹配策略尽可能的多 , 防止意外情况某一两个标识生成失败或者生成相同 。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;3、修改 &lt;code class=&quot;highlighter-rouge&quot;&gt;button&lt;/code&gt; 的状态。&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;1)、 如某个按钮点了会 &lt;code class=&quot;highlighter-rouge&quot;&gt;Crash&lt;/code&gt; 或暂时不需要被点击 , 但是又要展示出来 , 可以直接修改 &lt;code class=&quot;highlighter-rouge&quot;&gt;button&lt;/code&gt; 的 &lt;code class=&quot;highlighter-rouge&quot;&gt;enabled&lt;/code&gt; 属性 。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;blockquote&gt;
  &lt;p&gt;2)、 如某业务暂时关闭 , 可以直接修改入口 &lt;code class=&quot;highlighter-rouge&quot;&gt;按钮&lt;/code&gt; frame为0 , 前提是要自动布局已做好 。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;blockquote&gt;
  &lt;p&gt;3)、 如给购买 &lt;code class=&quot;highlighter-rouge&quot;&gt;按钮&lt;/code&gt; 添加监听事件 &lt;code class=&quot;highlighter-rouge&quot;&gt;addTarget: action: forControlEvents:&lt;/code&gt;&lt;/p&gt;
&lt;/blockquote&gt;

&lt;blockquote&gt;
  &lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;target&lt;/code&gt; 也可以通过上面 &lt;code class=&quot;highlighter-rouge&quot;&gt;遍历视图&lt;/code&gt; 获取到 , &lt;code class=&quot;highlighter-rouge&quot;&gt;action&lt;/code&gt; 可以由服务器下发 , 也可以一开始就写死 , 等有需求的时候直接传不同的参数就行了 。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;4、 绑定查找控件时 , 这个界面必须要已经初始化完成了才行 , 假如界面还没生成肯定是查找不到这个控件的 。 这里给大家提供两种思路 :&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;1、使用Runtime &lt;code class=&quot;highlighter-rouge&quot;&gt;Method Swizzing&lt;/code&gt; ,  直接把修改控件的方法与 &lt;code class=&quot;highlighter-rouge&quot;&gt;didMoveToSuperview&lt;/code&gt; 和 &lt;code class=&quot;highlighter-rouge&quot;&gt;didMoveToWindow&lt;/code&gt; 动态绑定 , 等这个控件加载出来之后再去修改 , 查找路径正确的话肯定就能找到了 。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;blockquote&gt;
  &lt;p&gt;2、在具体的类里面 , 等控件的初始化方法调用完后 , 再去执行动态修改 , 如在&lt;code class=&quot;highlighter-rouge&quot;&gt;viewDidLoad&lt;/code&gt; 里面初始化控件 , 在 &lt;code class=&quot;highlighter-rouge&quot;&gt;viewWillAppear:&lt;/code&gt; 里面动态修改 。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;blockquote&gt;
  &lt;p&gt;建议使用第一种适用范围更强 。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;上架后的 &lt;code class=&quot;highlighter-rouge&quot;&gt;应用&lt;/code&gt; 可能会遇到的一些突发状况 , 未测出的&lt;code class=&quot;highlighter-rouge&quot;&gt;Crash&lt;/code&gt;、临时改点小需求 , 等等 , 我们总不能每次因为一点小改动就重新提交一次 &lt;code class=&quot;highlighter-rouge&quot;&gt;App Store&lt;/code&gt; , 先不说 &lt;code class=&quot;highlighter-rouge&quot;&gt;App Store&lt;/code&gt; 的审核时间 , 频繁的让用户去更新应用 , 用户也会烦的 。使用这篇文章所讲的来实现动态更新是再合适不过了 。&lt;/p&gt;

&lt;p&gt;首先上面讲的 &lt;code class=&quot;highlighter-rouge&quot;&gt;动态更新&lt;/code&gt; 是完全脱离出来的一个模块 , 跟业务逻辑没有任何关系 , 只需要部署一次就行了 , 等开发下一个项目也可以直接拿过去使用 。这里的动态更新适用于局部的视图、控件的修改 , 如果你有其它需求可以考虑 &lt;a href=&quot;https://github.com/bang590/JSPatch&quot;&gt;JSPatch&lt;/a&gt; , 下发脚本也是一个不错的选择 。&lt;/p&gt;

&lt;h3 id=&quot;工具篇&quot;&gt;工具篇&lt;/h3&gt;
&lt;p&gt;使用一些UI调试的辅助工具 , 使我们查看视图在项目中得层次结构更为方便 。      &lt;br /&gt;
常用的UI调试的工具：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;Captuer View Hiearachy&lt;/li&gt;
  &lt;li&gt;Reveal&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Xcode自带的 &lt;code class=&quot;highlighter-rouge&quot;&gt;Captuer View Hiearachy&lt;/code&gt; 实现步骤:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;1、打开Xcode , 运行项目 , 选择最顶部的 &lt;code class=&quot;highlighter-rouge&quot;&gt;Debug&lt;/code&gt;&lt;/li&gt;
  &lt;li&gt;2、&lt;code class=&quot;highlighter-rouge&quot;&gt;Debug&lt;/code&gt; -&amp;gt; &lt;code class=&quot;highlighter-rouge&quot;&gt;View Debugging&lt;/code&gt; -&amp;gt; &lt;code class=&quot;highlighter-rouge&quot;&gt;Show View Frames&lt;/code&gt;&lt;/li&gt;
  &lt;li&gt;3、&lt;code class=&quot;highlighter-rouge&quot;&gt;Debug&lt;/code&gt; -&amp;gt; &lt;code class=&quot;highlighter-rouge&quot;&gt;View Debugging&lt;/code&gt; -&amp;gt; &lt;code class=&quot;highlighter-rouge&quot;&gt;Captuer View Hiearachy&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Xcode里面就变成了三维的视图了 , Xcode左侧展示出来的是层级关系的树状图 。&lt;/p&gt;

&lt;p&gt;Reveal的功能相对来说更强大 , 适用于UI调试视图查找 。使用方法请看 &lt;a href=&quot;http://support.revealapp.com/kb/getting-started/reveal&quot;&gt;Reveal集成指南&lt;/a&gt; 。&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;p&gt;转载请注明：&lt;a href=&quot;http://baixin&quot;&gt;潘柏信的博客&lt;/a&gt; » &lt;a href=&quot;http://baixin.io/2016/01/iOS_OTA/&quot;&gt;点击阅读原文&lt;/a&gt;&lt;/p&gt;

</description>
        <pubDate>Sat, 09 Jan 2016 19:15:06 +0800</pubDate>
        <link>http://localhost:4000/2016/01/iOS_OTA/</link>
        <guid isPermaLink="true">http://localhost:4000/2016/01/iOS_OTA/</guid>
        
        <category>iOS</category>
        
        
      </item>
    
      <item>
        <title>iOS 9 变化笔记</title>
        <description>&lt;p&gt;这里将介绍下我们日常开发一些从iOS8过度到iOS9给我们带来的一些变化，及解决方法。&lt;/p&gt;

&lt;h3 id=&quot;app-transport-security&quot;&gt;App Transport Security&lt;/h3&gt;

&lt;p&gt;iOS9和OS X El Capitan的一个新特性，App Transport Security 的目地是提高Apple 操作系统的安全性以及在此操作系统上运行的任何应用的安全性。ATS是苹果针对与 NSURL这一层做的封装，iOS9后ATS默认是开启的，即网络传输需要使用HTTPS。如果想在iOS9后继续使用HTTP的话，有两条路可以走：&lt;/p&gt;

&lt;blockquote&gt;
  &lt;ol&gt;
    &lt;li&gt;在Info.plist中添加 &lt;code class=&quot;highlighter-rouge&quot;&gt;NSAppTransportSecurity&lt;/code&gt;类型Dictionary，在&lt;code class=&quot;highlighter-rouge&quot;&gt;NSAppTransportSecurity&lt;/code&gt;下添加&lt;code class=&quot;highlighter-rouge&quot;&gt;NSAllowsArbitraryLoads&lt;/code&gt;，Boolean 为 YES。&lt;/li&gt;
    &lt;li&gt;直接使用CFNetwork做网络请求，ASIHTTPRequest就是基于CFNetwotk做的封装，如果有需求的同学可以看看ASI里面的源码，如果某个时间段你又想要使用HTTPS的话，ASI对SSL/TSL的证书验证有点问题，证书验证还得自己封装一下才行。刚才我说道，ATS是苹果针对与NSURL这一层做的封装，所以我们使用CFNetwork或者更底层做网络请求的话是不受ATS限制的。&lt;/li&gt;
  &lt;/ol&gt;
&lt;/blockquote&gt;

&lt;h3 id=&quot;移除了discoveryd-dns解析服务&quot;&gt;移除了discoveryd DNS解析服务&lt;/h3&gt;

&lt;p&gt;iPhone升级到iOS8后WiFi有时候会有问题，特别是Mac升级到OS X Yosemite后，时而电脑休眠唤醒唬就连不上WiFi，有时候还突然掉线，经常要手动去关闭WiFi在重新连接，这是因为苹果到了OS X Yosemite系统后，把之前的mDNSResponder换成了discoveryd DNS。iOS9和OS X Yosemite10.4后mDNSResponder又回来了。&lt;/p&gt;

&lt;p&gt;mDNSResponder： 苹果以前一直使用控制DNS和Bonjour服务的一种进程。
discoveryd：OS X Yosemite后苹果新出的一种进程。&lt;/p&gt;

&lt;h3 id=&quot;app-thinning&quot;&gt;App Thinning&lt;/h3&gt;
&lt;p&gt;App Thinning是一个关于节省iOS设备存储空间的功能，它可以让iOS设备在安装、更新及运行App等场景中仅下载所需的资源，减少App的占用空间，从而节省设备的存储空间。&lt;/p&gt;

&lt;h4 id=&quot;app-thinning主要有三个机制&quot;&gt;App Thinning主要有三个机制：&lt;/h4&gt;

&lt;blockquote&gt;
  &lt;ol&gt;
    &lt;li&gt;Slicing： 开发者把App安装包上传到AppStore后，Apple服务会自动对安装包切割为不同的应用变体(App variant)， 当用户下载安装包时，系统会根据设备型号下载安装对应的单个应用变体。&lt;/li&gt;
    &lt;li&gt;On-Demand Resources： ORD(随需资源)是指开发者对资源添加标签上传后，系统会根据App运行的情况，动态下载并加载所需资源，而在存储空间不足时，自动删除这类资源。&lt;/li&gt;
    &lt;li&gt;Bitcode：开启Bitcode编译后，可以使得开发者上传App时只需上传Intermediate Representation(中间件)，而非最终的可执行二进制文件。 在用户下载App之前，AppStore会自动编译中间件，产生设备所需的执行文件供用户下载安装。&lt;/li&gt;
  &lt;/ol&gt;
&lt;/blockquote&gt;

&lt;p&gt;其中，Bitcode的机制可以支持动态的进行App Slicing，而对于Apple未来进行硬件升级的措施，此机制可以保证在开发者不重新发布版本的情况下而兼容新的设备。Xcode7默认是开始了Bitcode，如果不想使用可以手动关闭Bitcode：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;选择项目——&amp;gt;点击Target——&amp;gt;点击Build Setttings——&amp;gt;搜索栏里搜bitcode——&amp;gt;把Enable Bitcode对应的Yes改成No。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;启用Bitcode编译机制，需要注意以下几点：&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;如果应用开启Bitcode，那么其集成的其他第三方库也需要是Bitcode编译的包才能真正进行Bitcode编译&lt;/li&gt;
  &lt;li&gt;开启Bitcode编译后，编译产生的.app体积会变大(中间代码，不是用户下载的包)，且.dSYM文件不能用来崩溃日志的符号化（用户下载的包是Apple服务重新编译产生的，有产生新的符号文件），使用dSYM来收集Crash日志的同学得注意了。&lt;/li&gt;
  &lt;li&gt;通过Archive方式上传AppStore的包，可以在Xcode的Organizer工具中下载对应安装包的新的符号文件&lt;/li&gt;
&lt;/ol&gt;

&lt;h3 id=&quot;后台定位&quot;&gt;后台定位&lt;/h3&gt;

&lt;p&gt;iOS9后苹果为了对保障用户的地理位置的隐私对App请求后台定位有了权限设置，则需要多加一些代码。如果不适配iOS9，就不能偷偷在后台定位，如果没有后台定位的权限也是可以在后台定位的，只是会出现蓝条。&lt;/p&gt;

&lt;p&gt;开启后台定位功能：&lt;code class=&quot;highlighter-rouge&quot;&gt;locationManager.allowsBackgroundLocationUpdates = YES;&lt;/code&gt;
locationManager是CLLocationManager的对象，用来管理整个定位的。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;重点：&lt;/strong&gt;&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;配置info.plist，添加一个Required background modes，Array类型的，然后在Required background modes里面Item 0对应的Value设置为App registers for location updates，这样就解决了iOS9后台定位出现蓝条的问题了。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h3 id=&quot;ui-testing&quot;&gt;UI Testing&lt;/h3&gt;
&lt;p&gt;Xcode7中苹果引入了一种新的方式在应用中进行测试——UI Testting，UI Testting允许我们找到UI元素与之交互，还能检查属性和状态。UI Testting已经完全集成进了Xcode7的测试报告，可以和单元测试一起执行。使用起来跟之前Xcode5出来的XCTest差不多，Xcode bots提供对此的支持，而且command line支持当UI测试失败时会立即发出通知。&lt;/p&gt;

&lt;p&gt;可以参考Github上的Demo，步骤：&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;在DemoTests.m里创建一个test开头的方法&lt;/li&gt;
  &lt;li&gt;在setUp()里启动应用 &lt;code class=&quot;highlighter-rouge&quot;&gt;XCUIApplication().launch()&lt;/code&gt;&lt;/li&gt;
  &lt;li&gt;新建一个方法test开头的，在里面获取应用&lt;code class=&quot;highlighter-rouge&quot;&gt;let app = XCUIApplication()&lt;/code&gt;&lt;/li&gt;
  &lt;li&gt;的到&lt;code class=&quot;highlighter-rouge&quot;&gt;let app = XCUIApplication()&lt;/code&gt;，a&lt;code class=&quot;highlighter-rouge&quot;&gt;pp.buttons[“View Detail”].tap()?&lt;/code&gt;。buttons是当前这个界面的所有按钮的集合，[]里面写按钮的名字，tap()就是执行这个按钮所对应的方法，可以是网络请求、界面跳转等等。&lt;/li&gt;
&lt;/ol&gt;

&lt;h3 id=&quot;url-scheme&quot;&gt;URL scheme&lt;/h3&gt;

&lt;p&gt;在iOS9中，如果使用URL scheme必须在”Info.plist”中将你要在外部调用的URL scheme列为白名单，否则不能使用。&lt;/p&gt;

&lt;p&gt;配置info.plist，添加一个&lt;code class=&quot;highlighter-rouge&quot;&gt;LSApplicationQueriesSchemes&lt;/code&gt;，Array类型的，然后在&lt;code class=&quot;highlighter-rouge&quot;&gt;LSApplicationQueriesSchemes&lt;/code&gt;的Item里面添加urlscheme就行了，urlscheme是任意一个字符串，就是你自己需要使用的urlscheme，iOS9 URL scheme白名单适配就完成了。&lt;/p&gt;

&lt;h3 id=&quot;出现大量的警告&quot;&gt;出现大量的警告&lt;/h3&gt;

&lt;p&gt;Xcode7后运行以前的项目后出现大量的警告如：&lt;/p&gt;

&lt;div class=&quot;language-bash highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;null&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt;: warning: /var/folders/p4/z7zy68r92hd3p5ry5g2v3k_8rlwzzr/C/org.llvm.clang.dalmo/ModuleCache/1TXZDLI9N2EMV/Foundation-3DFYNEBRQSXST.pcm: No such file or directory。
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;作为一个有洁癖的我反正是不能忍，出现警告的大致原因跟我上面提到的开启Bitcode，.dSYM文件不能用来符号化有关，Xcode试图去创建dSYM文件，但是你又不需要。&lt;/p&gt;

&lt;h3 id=&quot;解决方法&quot;&gt;解决方法&lt;/h3&gt;

&lt;ol&gt;
  &lt;li&gt;Build Settings ——&amp;gt;Build Options——&amp;gt;Debug Information Format&lt;/li&gt;
  &lt;li&gt;Debug下的DWARF with dsYM File改成DWARF&lt;/li&gt;
  &lt;li&gt;Release下的还是之前默认的DWARF with dsYM File不变&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;参考资料：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;a href=&quot;https://github.com/ChenYilong/iOS9AdaptationTips&quot;&gt;iOS9AdaptationTips&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;http://www.cocoachina.com/ios/20150821/13140.html&quot;&gt;iOS9学习系列&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://github.com/shinobicontrols/iOS9-day-by-day&quot;&gt;iOS9-day-by-day&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;p&gt;转载请注明：&lt;a href=&quot;http://baixin&quot;&gt;潘柏信的博客&lt;/a&gt; » &lt;a href=&quot;http://baixin.io/2015/09/iOS9_Note/&quot;&gt;点击阅读原文&lt;/a&gt;&lt;/p&gt;
</description>
        <pubDate>Sun, 27 Sep 2015 02:15:06 +0800</pubDate>
        <link>http://localhost:4000/2015/09/iOS9_Note/</link>
        <guid isPermaLink="true">http://localhost:4000/2015/09/iOS9_Note/</guid>
        
        <category>iOS</category>
        
        
      </item>
    
  </channel>
</rss>
